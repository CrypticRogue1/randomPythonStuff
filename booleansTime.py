
#Tried to do something with a True and False statement, but it didn't work out.
#spam1 = print("I guess it's booleans time!")
#spam2 = print("I guess it isn't booleans time!")
spam1 = True #If you put this line and the other False one in the shell, then it'll come out as either True/False
print(spam1) #Note: Figured out that you need to put print to print on console... huh.
spam2 = False
print(spam2)
#true # You can't use just true because it basically just a variable with nothing assigned to it
#True = 2 + 2 # Let's start with this then.
#^You can't use True because it's a boolean. Same with False.
true = 2 + 2
print(true)

#Essentially, True and False are specially booleans who love each other very much. 
#They wouldn't want to be assigned to a statement, but would rather claim when something is True of False.



# Comparison Operators:
# These are very similar to c++
# "==" <-- Equal
# "!=" <-- Not Equal
                                      # "<" <-- Less than
        #Then again                   # ">" <-- Greater than
   #It depends which one is which     # "<=" <-- Less than or greater than
                                      # ">=" <-- Greater than or equal to

# Boolean Operators:
    #and
        #and operator need everything to be true for it to be true, otherwise, it's false.
        # These are similar the c++:
        # True and True = True
        # True and False = False
        # False and True = False
        # False and False = False
            #In and, one False makes a difference. 
            #Like the Negative in math. (+ - = -) [Positive w/ Negative = Negative]
    #or
        #or operator has the opposite effect. This time instead of False affecting the outcome, it's True.
        # Something different from c++?:
        # True and True = True
        # True and False = True
        # False and True = True
        # False and False = False
            #In or, one True is all it takes.
            #Like how the life of the party is what makes everything so True.
    #not
        #The not operator is unary. Meaning, it doesn't need two things to find out if it's True of False
        #not just simply means no[or not]
         # not True = False
         # not False = True

print("At the end of the day, I'm gonna try some online notetaking on an actual dedicated app lol")
print("Though, let's review.")
print("The and operator needs False to lean it one way or another.")
print("The or operator needs True to lean it one way or another.")
print("The not operator simply means no[or not]")